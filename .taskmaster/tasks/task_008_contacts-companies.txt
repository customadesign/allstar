# Task ID: 8
# Title: Build ContactForm Component with React Hook Form and Zod Validation
# Status: pending
# Dependencies: 1, 3
# Priority: high
# Description: Create a reusable ContactForm component that handles both create and edit flows, implementing React Hook Form with Zod validation, including a tags multi-select and company autocomplete field.
# Details:
This task involves building a comprehensive ContactForm component that will be used for both creating and editing contacts:

1. Create `components/contacts/ContactForm.tsx` with the following structure:
   ```tsx
   import { useState, useEffect } from 'react';
   import { useForm, Controller } from 'react-hook-form';
   import { zodResolver } from '@hookform/resolvers/zod';
   import { z } from 'zod';
   import { TagPills } from '../shared';
   
   // Define Zod validation schema
   const contactSchema = z.object({
     firstName: z.string().min(1, 'First name is required'),
     lastName: z.string().min(1, 'Last name is required'),
     email: z.string().email('Invalid email format'),
     phone: z.string().optional(),
     company: z.object({
       id: z.string(),
       name: z.string()
     }).optional(),
     status: z.enum(['active', 'inactive', 'lead']),
     tags: z.array(z.string()).optional(),
     notes: z.string().optional()
   });
   
   type ContactFormValues = z.infer<typeof contactSchema>;
   
   interface ContactFormProps {
     initialData?: Partial<ContactFormValues>;
     onSubmit: (data: ContactFormValues) => void;
     onCancel: () => void;
     isSubmitting?: boolean;
   }
   
   export default function ContactForm({ 
     initialData = {}, 
     onSubmit, 
     onCancel, 
     isSubmitting = false 
   }: ContactFormProps) {
     // Set up React Hook Form with Zod validation
     const { 
       register, 
       handleSubmit, 
       control, 
       formState: { errors }, 
       reset 
     } = useForm<ContactFormValues>({
       resolver: zodResolver(contactSchema),
       defaultValues: initialData
     });
     
     // State for company autocomplete
     const [companySearchTerm, setCompanySearchTerm] = useState('');
     const [companyResults, setCompanyResults] = useState([]);
     const [availableTags, setAvailableTags] = useState([]);
     
     // Load available tags on component mount
     useEffect(() => {
       // In a real app, this would be an API call
       const mockTags = ['client', 'prospect', 'partner', 'vendor', 'internal'];
       setAvailableTags(mockTags);
     }, []);
     
     // Handle company search
     useEffect(() => {
       if (companySearchTerm.length > 2) {
         // In a real app, this would be an API call with debounce
         const mockCompanySearch = [
           { id: '1', name: 'Acme Inc' },
           { id: '2', name: 'Globex Corporation' },
           { id: '3', name: 'Initech' }
         ].filter(company => 
           company.name.toLowerCase().includes(companySearchTerm.toLowerCase())
         );
         setCompanyResults(mockCompanySearch);
       } else {
         setCompanyResults([]);
       }
     }, [companySearchTerm]);
     
     // Reset form when initialData changes
     useEffect(() => {
       reset(initialData);
     }, [initialData, reset]);
     
     return (
       <form onSubmit={handleSubmit(onSubmit)} className="space-y-6">
         <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
           {/* First Name Field */}
           <div>
             <label htmlFor="firstName" className="block text-sm font-medium text-gray-700">
               First Name *
             </label>
             <input
               id="firstName"
               type="text"
               {...register('firstName')}
               className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
             />
             {errors.firstName && (
               <p className="mt-1 text-sm text-red-600">{errors.firstName.message}</p>
             )}
           </div>
           
           {/* Last Name Field */}
           <div>
             <label htmlFor="lastName" className="block text-sm font-medium text-gray-700">
               Last Name *
             </label>
             <input
               id="lastName"
               type="text"
               {...register('lastName')}
               className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
             />
             {errors.lastName && (
               <p className="mt-1 text-sm text-red-600">{errors.lastName.message}</p>
             )}
           </div>
           
           {/* Email Field */}
           <div>
             <label htmlFor="email" className="block text-sm font-medium text-gray-700">
               Email *
             </label>
             <input
               id="email"
               type="email"
               {...register('email')}
               className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
             />
             {errors.email && (
               <p className="mt-1 text-sm text-red-600">{errors.email.message}</p>
             )}
           </div>
           
           {/* Phone Field */}
           <div>
             <label htmlFor="phone" className="block text-sm font-medium text-gray-700">
               Phone
             </label>
             <input
               id="phone"
               type="tel"
               {...register('phone')}
               className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
             />
             {errors.phone && (
               <p className="mt-1 text-sm text-red-600">{errors.phone.message}</p>
             )}
           </div>
           
           {/* Company Autocomplete */}
           <div>
             <label htmlFor="company" className="block text-sm font-medium text-gray-700">
               Company
             </label>
             <Controller
               name="company"
               control={control}
               render={({ field }) => (
                 <div className="relative">
                   <input
                     type="text"
                     value={companySearchTerm}
                     onChange={(e) => setCompanySearchTerm(e.target.value)}
                     placeholder="Search for company..."
                     className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
                   />
                   {companyResults.length > 0 && (
                     <ul className="absolute z-10 mt-1 max-h-60 w-full overflow-auto rounded-md bg-white py-1 text-base shadow-lg ring-1 ring-black ring-opacity-5 focus:outline-none sm:text-sm">
                       {companyResults.map((company) => (
                         <li
                           key={company.id}
                           className="relative cursor-default select-none py-2 pl-3 pr-9 hover:bg-indigo-100"
                           onClick={() => {
                             field.onChange(company);
                             setCompanySearchTerm(company.name);
                             setCompanyResults([]);
                           }}
                         >
                           {company.name}
                         </li>
                       ))}
                     </ul>
                   )}
                   {field.value && (
                     <div className="mt-2 flex items-center">
                       <span className="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-blue-100 text-blue-800">
                         {field.value.name}
                         <button
                           type="button"
                           className="ml-1 inline-flex text-blue-400 hover:text-blue-600"
                           onClick={() => {
                             field.onChange(undefined);
                             setCompanySearchTerm('');
                           }}
                         >
                           &times;
                         </button>
                       </span>
                     </div>
                   )}
                 </div>
               )}
             />
             {errors.company && (
               <p className="mt-1 text-sm text-red-600">{errors.company.message}</p>
             )}
           </div>
           
           {/* Status Field */}
           <div>
             <label htmlFor="status" className="block text-sm font-medium text-gray-700">
               Status *
             </label>
             <select
               id="status"
               {...register('status')}
               className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
             >
               <option value="active">Active</option>
               <option value="inactive">Inactive</option>
               <option value="lead">Lead</option>
             </select>
             {errors.status && (
               <p className="mt-1 text-sm text-red-600">{errors.status.message}</p>
             )}
           </div>
         </div>
         
         {/* Tags Multi-select */}
         <div>
           <label className="block text-sm font-medium text-gray-700">
             Tags
           </label>
           <Controller
             name="tags"
             control={control}
             defaultValue={[]}
             render={({ field }) => (
               <div>
                 <div className="flex flex-wrap gap-2 mt-2">
                   {availableTags.map(tag => (
                     <TagPills
                       key={tag}
                       label={tag}
                       selected={field.value?.includes(tag)}
                       onClick={() => {
                         const currentTags = field.value || [];
                         if (currentTags.includes(tag)) {
                           field.onChange(currentTags.filter(t => t !== tag));
                         } else {
                           field.onChange([...currentTags, tag]);
                         }
                       }}
                     />
                   ))}
                 </div>
               </div>
             )}
           />
         </div>
         
         {/* Notes Field */}
         <div>
           <label htmlFor="notes" className="block text-sm font-medium text-gray-700">
             Notes
           </label>
           <textarea
             id="notes"
             rows={4}
             {...register('notes')}
             className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
           />
         </div>
         
         {/* Form Actions */}
         <div className="flex justify-end space-x-3">
           <button
             type="button"
             onClick={onCancel}
             className="px-4 py-2 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
           >
             Cancel
           </button>
           <button
             type="submit"
             disabled={isSubmitting}
             className="px-4 py-2 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 disabled:opacity-50"
           >
             {isSubmitting ? 'Saving...' : initialData.id ? 'Update Contact' : 'Create Contact'}
           </button>
         </div>
       </form>
     );
   }
   ```

2. Implement the following features in the ContactForm component:
   - Form validation using Zod schema
   - React Hook Form integration for form state management
   - Field-level error messages
   - Company autocomplete with search functionality
   - Tags multi-select using the TagPills component from shared UI
   - Support for both create and edit modes based on initialData
   - Responsive layout using Tailwind CSS grid

3. Ensure the form handles the following fields:
   - First Name (required)
   - Last Name (required)
   - Email (required, valid format)
   - Phone (optional)
   - Company (optional, with autocomplete)
   - Status (required, select from options)
   - Tags (optional, multi-select)
   - Notes (optional, textarea)

4. Implement proper TypeScript typing:
   - Use Zod to infer the form value types
   - Create appropriate interfaces for component props
   - Ensure type safety for all form operations

5. Add appropriate loading and error states:
   - Disable submit button during form submission
   - Show loading indicator when appropriate
   - Handle validation errors with clear user feedback

# Test Strategy:
To verify the correct implementation of the ContactForm component:

1. Component Structure Verification:
   - Confirm the ContactForm.tsx file exists in the components/contacts/ directory:
     ```bash
     ls -la components/contacts/ContactForm.tsx
     ```
   - Verify the component exports correctly:
     ```bash
     grep -E "export default function ContactForm" components/contacts/ContactForm.tsx
     ```

2. Form Validation Testing:
   - Test form submission with empty required fields:
     - Submit the form without filling in first name, last name, and email
     - Verify error messages appear for each required field
   - Test email validation:
     - Enter an invalid email format (e.g., "test@" or "test")
     - Verify the email validation error message appears
   - Test form submission with valid data:
     - Fill in all required fields with valid data
     - Verify the form submits successfully and calls the onSubmit handler

3. Multi-select Tags Testing:
   - Click on various tags to select them
   - Verify selected tags are visually indicated
   - Click on selected tags to deselect them
   - Verify the tags array in the form data updates correctly

4. Company Autocomplete Testing:
   - Type at least 3 characters in the company field
   - Verify the dropdown appears with matching company results
   - Select a company from the dropdown
   - Verify the selected company appears as a chip/pill
   - Test clearing the selected company
   - Verify the company field resets correctly

5. Form Mode Testing:
   - Test the form in create mode (no initialData.id):
     - Verify the submit button shows "Create Contact"
     - Verify all fields are empty or have default values
   - Test the form in edit mode (with initialData.id):
     - Verify the submit button shows "Update Contact"
     - Verify all fields are pre-populated with initialData values

6. Responsive Layout Testing:
   - Test the form on desktop viewport:
     - Verify the form fields display in a two-column layout
   - Test the form on mobile viewport:
     - Verify the form fields collapse to a single column layout

7. Integration Testing:
   - Import the ContactForm component in a test environment
   - Mock the onSubmit and onCancel handlers
   - Render the component with and without initialData
   - Verify the handlers are called with the correct parameters
   - Test the form reset functionality when initialData changes
